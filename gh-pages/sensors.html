<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Wired Sensors</title>
</head>
<body>
<h1>Wired Sensors</h1>
<p>This part of the documentation describes the sensors interface. With sensors
  we mean devices that are physically connected/attached to the Raspberry&nbsp; to one
  of the GPIO pins. So they are connected with a physical wire. Sensors typically
  are temperature/humidity interfaces or energy sensors.</p>
<p>What makes sensors different from the &quot;normal&quot; receivers: The
  latter operate asynchronously and begin to send as they like it. The connected
  wire sensors will only start once they receive a command over the line from the
  MCU (Micro Controlling Unit aka Raspberry).</p>
<p>For the sake of simplicity, I like to categorize wired sensors in the
  following groups:</p>
<ol>
  <li><a href="#nobus">Sensors without a bus mechanism, so every sensor might have its own
    protocol and will be connected to a free GPIO pin</a>.</li>
  <li><a href="#dallas">Single- or One-Wire sensors with Dallas bus protocol</a></li>
  <li><a href="i2c">Two-wire sensors on the I2C bus</a></li>
  <li><a href="#energy">Energy sensors, connected to the  P1 bus of your Smart Meter</a></li>
</ol>
<h2><a name="nobus"></a>1. Wired Sensors, no bus</h2>
<p>The first catagory to describe is the group of sensors that do not use a bus system to connect to the Raspberry PI (so have multiple sensors in series connected to the same wire). Instead every sensor will need to be connected separately to VCC and GND as well as be assigned its own exclusive GPIO pin.</p>
<p>This may or may not be sufficient for your use, but there is an advantage to this approach: These sensors in general are cheap and contain good value. There is however a drawback when using these devices (as will be explained in further details below): If we connect these sensors to a busy system the timing of the system might not be good enough to support the critical timing (in 20uSec) that these devices need.</p>
<h4>What Sensors are supported:</h4>
<ul>
  <li>DHT11
    (1 &ordm;C accuracy) </li>
  <li>DHT22
    sensors (0.1 &ordm;C accuracy)</li>
</ul>

<h3>1.1 The DHT11 temperature and humidity sensor</h3>
<p>The DHT11 temperature/humidity sensor is a typical example of such a sensor
  device. It has 3 outside connector pins: GND, VCC and Data. Of course the
  latter will be the most important pin to work with. In case of the DHT11 we
  need to send a start pulse to the data pin, wait a predefined number of micro
  seconds and then we will receive the 40-bit (5 bytes) sensor reading from the
  device as 2 bytes humidity reading, 2 bytes temperature reading. And 1 byte for
  parity check.</p>
<p>Connecting the DHT11 is easy, it is low cost and easy to connect. However,
  you are advised to buy the slightly more expensive DHT22 model instead. The
  DHT11 does not output decimal parts of the temperature and humidity (decimal
  part of the output bytes are always 0). The DHT22 is fully compatible with the
  DHT11 but will provide temperature readings with 0.1 degree Celsius precision. </p>
<p>&nbsp;<img src="sensors/DHT11/88dht11.jpg" alt="" width=400 height=400></p>
<p>The DHT11 is not compatible with the Dallas 1-wire bus protocol (see below)
  which makes it a less flexible choice, even with its low pricetag.</p>
  
<h3>1.2 Software Design Considerations</h3>
<p>Writing a software program to read the temperature and humidity values from
  a sensor is a relatively simple task. In case of the DHT11 one needs to send a
  pulse sequence over the data pin which tells the sensor to send its data, wait
  a predefined number of microseconds and the sensor will take over the data line
  and starts sending its 40 bits of data.</p>
<p>In principle, all you have to do is read the status of the data line in uSec
  time intervals and as soon as the data line switches from high to low, or vice
  versa, note the pulse time. Every bit transmitted starts with 50uSecs High
  value followed by a pulse of 25 uSec means a 0 value or a pulse of around 70
  uSecs which means a logical 1.</p>
<p>There are a few methods for reading one-wire sensors:</p>
<ol>
  <li>Write the sensor command to the data pin and when the sensor responds
    read its value (HIGH or LOW) in a loop. Record the time between HI-LO or LO-HI&nbsp;
    transitions</li>
  <li>Write the sensor command to the data pin, and use an interrupt handler
    that is activated on either a rising or falling edge (HI-LO and LO-HI) and record the time
    intervals between the transitions.</li>
  <li>Make use of the readRHT03 function in the dev library in wiringPI. There is support for RHT03 (and DHT11, DHT22). </li>
</ol>
<p>The first method described above is a brute-force method: we read the
  value/level of the data pin every uSec in loop and as soon as the sensor
  changes state/value we record the time interval since the last state change.
  This might consume an undesired amount of CPU resources. But there is a more
  important reason why the simple read might not work: If you use other sensors
  or wireless devices that use interrupt handlers to read incoming messages, your
  reads will not be timed correctly as these interrupts are handled with a higher
  priority than other running processes.</p>
<p>As an alternative, it is possible to use an interrupt handler to measure
  and time signal transitions on the data pin. The time difference between 2
  transitions will be an indicator of &ldquo;0&rdquo; or &ldquo;1&rdquo; values. My experience with the
  last method is mixed: The method works much better when there is a lot of other
  data to read. But the timing of the data line is still critical and the sensor
  pulses are really short, even for the RaspberryPI. Especially when other
  interrupts arrive (433 MHz data for example) it is possible that a transition
  is not noticed and timing of two pulses is combined (and there is one pulse
  time less in the buffer).</p>
<p>Of course it is possible to NOT connect any 433MHz receivers to the
  Raspberry, in which case a single sensor can be read quite reliably. However,
  in our Home Automation application 433MHz receivers are key. And sad-but-true,
  there is a HUGE amount of 433 MHz noise in and around the home which causes
  lots of meaningless interrupts to the application. There are good and better
  (more selective) receivers, and some have developed a low-pass filter for
  433MHz receivers. However, when weather station start with theirs 60-second
  data bursts the amount of interrupts on the receiver pin is enormous (leading
  to 20-30% cpu usage).</p>
<p>The third method is easy on the programmer. There are two functions available in the wiringPI dev library that support the Max functions: readRHT03() and maxDetectRead().</p>
<h3>1.3 Test</h3>
<p>I did some tests to measure the performance of the three methods. I tested method 2 and 3 in two ways: (a) Without any other (major) load on the RPI, and (b) with the LamPI-receiver process running, so that all other 433MHz receiver interrupts needed to be dealt with as well.</p>
<p>For every method tested I made sure that we raised the interrupt priority prior to reading a value, and dropped it to 0 again after an successful read. This is done as reading a sensor is a synchronous operation (as seen by the initiating LamPI daemon) and we wait it to be successful and as short as possible (time). Compared to 433MHz interrupts that are generated by the receiver as a result of a remote sending a value. These asynchronous and autonome transmissions are handled by the daemon and if we miss one of those we'll pick up the next transmission.</p>
<h4>method 1a:</h4>
<p><img src="sensors/DHT11/screenshot_force_a.JPG" width="587" height="323"></p>
<h4>Method 1b: </h4>
<p><img src="sensors/DHT11/screenshot_force_b.JPG" width="568" height="327"></p>
<h4>method 2a: Use an interrupt function to measure temperature (no load)</h4>
<p><img src="sensors/DHT11/screenshot_interrupt_a.JPG" width="608" height="323"></p>
<p>As you can see in the results above, an average successful read in a system without load takes about 3 seconds (including a 500 ms start delay between read attempts and some other short wait times)</p>
<h4>method 2b: Use an interrupt function to measure temperature (under load)</h4>
<p><img src="sensors/DHT11/screenshot_interrupt_b.JPG" width="594" height="324"></p>
<p>The figure above tells us that for reading 10 successful values we have a total elapsed time of 1 minute and 17 seconds, which means that a successful read  takes 7.7 second on average. Still this figure is a little misleading: Not every read attempt is successful, and in the program we wait 500 milliseconds between attempts. This is because the datasheet mentions a mandatory time delay of about 1 second between read attempts. It is possible to leave out his wait, this will cause no major problems, other than that reads become less accurate (probably because the sensor cannot auto adjust between read attempts).</p>
<h4>method 3a: Use the built-in wiringPI function:</h4>
<p><img src="sensors/DHT11/screenshot_devlib_a.JPG" width="605" height="326"></p>
<p>As you can see, the built-in function in the wiringPi library is highly efficient in an unloaded sitution.</p>
<h4>method 3b: Measuring under load</h4>
<p><img src="sensors/DHT11/screenshot_devlib_b.JPG" width="605" height="325"></p>
<p>And the built-in function is very much inefficient if the system is handling regular 433MHz receiver interrupts. Also errors are introduced (even with checksum) that make its results unreliable. In practice this means that the wiringPi library function has to redo an enormous amount of read attempts that did not pass the checksum test.</p>
<p>&nbsp;</p>
  
<h3>1.4 Conclusion</h3>
<p>For reasons described above, a non-bus interface may not always be the best
  solution for connecting sensors. Timing issues are already an issue when having
  one sensor connected to one GPIO pin, let alone when we would like to have
  multiple sensors connected to our Raspberry. </p>
<p>Therefore, I will further experiment with other 1-wire (Dallas) and 2-wire sensor (I2C) bus
  interconnects. Read more below.</p>
<p>&nbsp;</p>
<h2><a name="dallas"></a>2. MicroLAN or Dallas OneWire sensors</h2>
<p>The third method described uses a 1-wire module interface to retrieve the values
  from a slave device. This interface is called MicroLAN and has been defined by
  Dallas Semiconductors. Users can access sensor values by reading the value of
  the slave device in the /sys/bus/w1/device directory. Standard modules w1-gpio
  and w1-therm then will control the low-level details of the communication. And
  we can open a device in the /sys/bus/w1/device directory and read the values
  from there. The DS18B20 temperature sensor is an example of a 1-wire capable
  sensor device compatible with the Dallas/MicroLAN specification.</p>
<p>The MicroLAN bus is slower than the 2-wire I2C bus, but as a result it can
  be (much) longer. Sources on internet specify a length of 100 meters or more
  (over CAT 5e Ethernet cable).</p>
<ul>
  <li>DS18B20
    temperature sensor (1-wire Dallas compatible)</li>
  <li></li>
</ul>
<h3>2.1 The 18B20 temperature sensor</h3>
<p>I bought 5 DS18B20 temperature sensors for LamPI environment and plan to
  make a small MicroLAN network with them.</p>
<p><img
src="sensors/DS18B20/18b20_1.jpg" alt="" width=338 height=327 id="Picture 7"></p>
<p><img src="sensors/DS18B20/18b20_2.jpg" width="463" height="452"></p>
<p>These sensors look just like a transistor which makes them relatively easy
  to work with. In the picture you see the cheap standard version. High
  temperature and water resistant versions are available as well. In order to test the Dallas bus I ordered 5 of the cheap standard sensors and 2 water resistant sensors.</p>
<h3>2.2 Resources</h3>
<ul>
  <li>w1-gpio
    module (sudo modprobe w1-gpio to load)
    </p>
  </li>
  <li>w1-therm
    module</li>
</ul>
<p>Load both modules with the modprobe command:</p>
<p><img src="sensors/DS18B20/code_1.JPG" width="425" height="45"></p>
<p>After the modules are loaded it is easy to read the value of the sensors. Go to the /sys/bus/w1/devices directory and list the directories and files. Apart from the w1_bus_master command there will be one or more other directories, one for every device on the bus.</p>
<p>For the ds18b20 sensor, the directory name will start with 28- . Go to one of the ds18b20 directorys and use the following command to read the current termperature at the sensor:</p>
<p><img src="sensors/DS18B20/code_2.JPG" width="664" height="180"></p>
<p>Both modules w1-therm and w1-gpio need to be loaded prior to their usage. By
  default, GPIO pin 4 (P1 connector 7) is used. </p>
<h3>2.3 Software</h3>
<p>The small C software program can be found in the sensors/ds18b20 directory. The software program is very simple in design, as all low-level synchronization and interrupt handling is done completely in the module. As a result, the bus softwar eis very (I mean VERY) reliable compared to the DS11, especially when the system is serving a lot of other interrupts, socket messages and user interaction.</p>
<p>My situations is the same as in the picture below (found it on the web somewhere). I have three sensors connnected to my RPI and read them with a small program..</p>
<p><img src="sensors/DS18B20/ds1820connect.png" width="345" height="285"></p>
<p>Maybe a restart is required to have your RPI recognized the modules, but after that  the device &quot;files&quot; w1_slave in the /sys/but/w1/device/28*/ directories can be read and will contain the lines we're loooking for ..</p>
<p><img src="sensors/DS18B20/code_3.JPG" alt="" width="837" height="525"></p>
<p>In the picture above you see a real-world example of my RaspberriPI that contains 3 Maxim sensors (w1). Clearly you can see that listing the /sys/bus/devices directory shows 3 connected sensors and the master node (skip that one).</p>
<p>After changing directory to one of the sensor dirs (starting with 28-) , reading the w1_slave file will result in 2 lines being read. The first line contains the data followed by a checksum. Only when the checksum is Ok (YES) then we know that the sensor can be read successfully. The second line read contains the data as well as the temperature (* 1000). You get the actual temperature by dividing the value by 1000, so in this case the measured temperature is 22.125 degrees C. </p>
<p>A quick test of the CRC function can be done by removing one of the sensors, which will for a while result in a checksum error and data errors (obviously). Note that after a while the third sensor completely disappeared from my system so the system has some self-healing properties. Luckily, installing the sensor again (in a live system) is possible and will immediately result in that sensor being available again.</p>
<p>There are several examples on the net how to read the device files, most however are written in script language. As I wanted to post successful temperature readings to the LamPI-daemon for further processing, I made a little program in C that opens a socket and reads all sensors and sends the output to the LamPI-daemon. The source code can be found on ~/sensors/ds18b20, and after a successful 'sudo make install' the executable is put in the ~/exe directory</p>
<h3>2.4 Conclusion</h3>
<p>The dallas 1-wire bus works VERY well, and the devices/bus is well supported by the RPI. Only drawback is that there are only a small amount of sensors available for Dallas. But the ds18b20 temperature sensors is a very good example of sensors that work very well and that are worth every penny and second of your time if temperature sensors is your main interest.</p>
<h3>2.5 Links</h3>
<ul>
  <li><a href="http://kopfkino.irosaurus.com">http://kopfkino.irosaurus.com</a> (German site)</li>
  <li>http://www.sbprojects.com/projects/raspberrypi/temperature.php</li>
  <li><a
href="http://www.1wire.org/Files/Articles/1-Wire-Design%20Guide%20v1.0.pdf">http://www.1wire.org/Files/Articles/1-Wire-Design%20Guide%20v1.0.pdf</a></li>
  <li><a
href="http://learn.adafruit.com/downloads/pdf/adafruits-raspberry-pi-lesson-11-ds18b20-temperature-sensing.pdf">http://learn.adafruit.com/downloads/pdf/adafruits-raspberry-pi-lesson-11-ds18b20-temperature-sensing.pdf</a></li>
</ul>
<p>&nbsp;</p>
<h2><a name="i2c"></a>3. I2C Bus Sensors</h2>
<p>A completely different way of connecting temperature, humidity and lots of
  other sensors to the Raspberry PI is by using I2C compatible sensors like the
  AM2321. I2C is a software/hardware bus to connect several devices to the same
  GPIO pins and still control each one of them. This sharing of Raspberry
  resources offers important benefits:</p>
<ul>
  <li>Less
    timing and priority setting issues between devices</li>
  <li>Up
    to 128 devices connected with only a clock and a data pin&nbsp; (2-wire protocol)</li>
</ul>
<p>The I2C bus is a 2-wire system (actually with power and ground wire it is 4) with a data pin and a clock pin. It is wired as follows, a device needs 4 wires as a minimum as
  shown in the diagram below. However, some devices have several additional pins to
  control bus addressing and interrupts for example.</p>
<p>The I2C bus is much faster than the Dallas bus at a cost of distance. Where it is possible with Dallas to have long leads to your sensors and a connection of a 100 meters to your RPI, with the I2C bus the distance will be in the range of cm (centi- meters). Not that the latter matters a lot: I can easlily remember a dedicated RPI with a small board connecting 5-10 different sensors.</p>
<p>&nbsp;</p>
<p><img src="sensors/i2c.png" alt="" width=773 height=452 border=0></p>
<h5>In the picture above, scl is the system clock (pin
  xxx) and dat is the data pin (pin yyy).</h5>
<p>The wiringPI library offers support for reading the I2C bus, and there are several available at reasonable price. However the Dallas bus is easier to read, and it is very reliable. So let's review the I2C bus. </p>
<h3>3.1 Common I2C Sensors available</h3>
<p>The following (not so expensive) sensors are available for connection to the
  LamPI system.</p>
<ul>
  <li>BMP085,
    I2C Digital Barometric Pressure Sensor board Barometer sensor module</li>
  <li>AM2321,
    Humidity and Temperature Sensor (ordered)</li>
  <li>LM75,
    Temperature Sensor (ordered)</li>
  <li>HMC5883,
    3-axis digital compass</li>
  <li>MMA7455,
    Digital accelerator sensor</li>
  <li>MPL3115A2,
    Altimeter, Temperature and Pressure sensor </li>
</ul>
<p>&nbsp;</p>
<h3>3.2  Temperature Sensor LM75</h3>
<p>The LM75 is a cheap example of an I2C capable sensor. Several people have
  connected this sensor to the Raspberry and achieved promising results.</p>
<p><img
src="sensors/LM75/lm75.jpg" alt="" width=500 height=400 border=0 id="Picture 6"></p>
<p>As you can see in the picture, soldering these small IC&rsquo;s is a challenge.</p>
<p>&nbsp;</p>
<h3>3.3 Barometric Pressure Sensor BMP085</h3>
<p>Another interesting sensors available on the I2C bus is the barometric
  pressure sensor. It can be bought on eBay with free shipping for as low as $
  6.00. Next to the barometric pressure it can also measure the temperature. </p>
<p><img
src="sensors/BMP085/BMP085_LRG.jpg" alt="" width=600 height=461 border=0 id="Picture 22"></p>
<h3>Programming I2C</h3>
<p>By default, the I2C bus module is blacklisted on the RPI. Edit the /etc/modprobe.d/raspi-blacklist.conf file and uncomment the module (put a # character as first character of the line). </p>
<h3>Links</h3>
<ul>
  <li><a
href="http://www.keesmoerman.nl/rasp_hw.html#mozTocId335084">http://www.keesmoerman.nl/rasp_hw.html#mozTocId335084</a></li>
  <li></li>
</ul>

<h2>&nbsp;</h2>
<h2><a name="energy"></a>4. Energy Sensors</h2>
<p>By the year 2018, all Dutch homes will have a &quot;smart&quot; meter for electricity
  and heating with natural gas. The so-called P1 port on the electricity meter
  offers access to the electricity and gas usage over its serial line interface.</p>
<p>The P1 port is accessible by home owners and allows them to read power usage
  and natural gas usage on a permanent basis.</p>

</body>
</html>
